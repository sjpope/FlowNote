{% extends 'base.html' %}

{% block content %}
<div class="full-page">
  <h2 style="text-decoration: underline;">{{ note.title }}</h2>
  <p><strong>Created At:</strong> {{ note.created_at|date:"F d, Y H:i" }}</p>
  <p><strong>Last Updated:</strong> {{ note.updated_at|date:"F d, Y H:i" }}</p>
  <p><strong>Summary:</strong> {{ note.summary }}</p>
  <div class="content-area">
    {{ note.content|safe }}
  </div>
  
  <p>By: {{ note.owner }}</p>

  {% if messages %}
    <ul class="messages">
        {% for message in messages %}
            <li{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</li>
        {% endfor %}
    </ul>
  {% endif %}

  {% if note.analysis %}
    <h3>Analysis</h3>
    <p>{{ note.analysis }}</p>
  {% endif %}

  <div class="button-group">
    <button><a href="{% url 'notes:note_update' note.id %}" class="btn btn-primary">Update</a></button>
    <button><a href="{% url 'notes:note_delete' note.id %}" class="btn btn-danger">Delete</a></button>
  </div>


  {% comment %} <form action="{% url 'notes:analyze' note.id%}" method="post">
    {% csrf_token %}
    <input type="hidden" id="ajaxAnalyzeUrl" value="{% url 'notes:analyze' note.id %}">
    <button type="submit" class="btn btn-secondary">Analyze Note</button>
  </form> {% endcomment %}

  {% include 'assistant.html' %}

  <button id="analyzeNoteBtn" data-note-id="{{ note.id }}" data-analyze-url="{% url 'notes:analyze' note.id %}">Analyze Note</button>
  <div id="analysisResult"></div>

  <h3>Auto Grouping</h3>
  <form action="{% url 'notes:auto_group_note' note.id %}" method="post">
    {% csrf_token %}
    <button type="submit" class="btn btn-secondary">Auto Group This Note</button>
  </form>

  <!-- Content Generation -->
  <div class="generate-content-form">
    <label for="prompt-input" class="form-label">Enter a prompt:</label>
    <div class="input-group mb-3">
      <input type="text" id="prompt-input" placeholder="Enter a prompt..." class="form-control">
      <button id="generate-content-btn" data-note-id="{{ note.id }}" class="btn btn-success">Generate</button>
    </div>
  </div>

  <div id="content-container" class="content-display-area mt-4 p-3" style="background-color: #f8f9fa; border-radius: 5px;"></div>


</div>
<style>
  .generate-content-form {
    margin-top: 20px;
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .content-display-area {
    margin-top: 20px;
    background: #f2f2f2;
    padding: 20px;
    border-radius: 10px;
  }

  .container {
    text-align: left;
    display: flex;
    flex-direction: column;
    justify-content: start;
    align-items: start;
  }

  .button-group {
    margin-top: 10px;
    margin-bottom: 20px;
  }

  .button-group button {
    margin-right: 10px;
    background-color: var(--button-bg-color);
    padding: 10px;
    border-radius: 9px;
    border: none;
  }

  .button-group button a {
    text-decoration: none;
    color: rgb(255, 255, 255);
  }

  .content-area {
    background-color: var(--form-color);
    border-radius: 16px;
    padding: 15px 40px 20px 20px;
  }
</style>

{% endblock %}

{% block javascript %}
<script>
  // GENERATE CONTENT
  document.addEventListener("DOMContentLoaded", function() {
    const generateContentBtn = document.getElementById('generate-content-btn');
    const contentContainer = document.getElementById('content-container');
  
    generateContentBtn.addEventListener('click', function(e) {
      e.preventDefault();
      const noteId = this.getAttribute('data-note-id');  
      const prompt = document.getElementById('prompt-input').value;
  
      // Step 1: Initiate content generation
      fetch(`/generate-content/${noteId}?prompt=${encodeURIComponent(prompt)}`)
        .then(response => response.json())
        .then(data => {
            // Step 2: Start polling for task status
            const taskId = data.task_id;
            pollTaskStatus(taskId);
        })
        .catch(error => console.error('Error generating content:', error));
  
      function pollTaskStatus(taskId) {
        const interval = setInterval(() => {
          fetch(`/task-status/${taskId}`)
            .then(response => response.json())
            .then(data => {
                if (data.status === 'SUCCESS') {
                    clearInterval(interval);  // Stop polling once the task is complete
  
                    // Step 3: Update the UI with the generated content
                    contentContainer.innerHTML = '';  // Clear previous content
                    const contentParagraph = document.createElement('p');
                    contentParagraph.textContent = data.result;  // Assuming 'data.result' contains the generated content
                    contentContainer.appendChild(contentParagraph);
                } else if (data.status === 'FAILURE') {
                    clearInterval(interval);  // Stop polling if the task fails
                    console.error('Task failed:', data.error);  // Handle task failure
                    contentContainer.innerHTML = '<p>Content generation failed. Please try again.</p>';
                }
                // Handle 'PENDING' status ?
            })
            .catch(error => {
                clearInterval(interval);
                console.error('Error polling task status:', error);
            });
        }, 2000);  // Poll every 2 seconds
      }
    });
  });

  // AUTOCOMPLETE
  document.addEventListener("DOMContentLoaded", function() {
    const contentInput = document.getElementById('note-content-input');
    const suggestionsContainer = document.getElementById('autocomplete-suggestions');

    contentInput.addEventListener('input', _.debounce(function() {  
        const currentText = contentInput.value;
        fetch(`/autocomplete?text=${encodeURIComponent(currentText)}`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
            },
        })
        .then(response => response.json())
        .then(data => {
            suggestionsContainer.innerHTML = '';  
            data.suggestions.forEach(suggestion => {
                const suggestionElement = document.createElement('div');
                suggestionElement.textContent = suggestion;
                suggestionElement.classList.add('autocomplete-suggestion');
                
                suggestionElement.addEventListener('click', function() {
                    contentInput.value += ' ' + suggestion.split(' ').slice(-2).join(' ');  
                    suggestionsContainer.innerHTML = ''; 
                });
                
                suggestionsContainer.appendChild(suggestionElement);
            });
        })
        .catch(error => console.error('Error fetching autocomplete suggestions:', error));
    }, 300));  

    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
          const cookies = document.cookie.split(';');
          for (let i = 0; i < cookies.length; i++) {
              const cookie = cookies[i].trim();
              if (cookie.substring(0, name.length + 1) === (name + '=')) {
                  cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                  break;
              }
          }
      }
      return cookieValue;
    }
  });

  // ANALYZE NOTE BUTTON
  document.addEventListener("DOMContentLoaded", function() {
    const analyzeBtn = document.getElementById("analyzeNoteBtn");
  
    analyzeBtn.addEventListener("click", function(e) {
      e.preventDefault();
      const analyzeUrl = this.getAttribute("data-analyze-url");
      
      fetch(analyzeUrl, {
        method: 'POST',
        headers: {
          'X-CSRFToken': getCookie('csrftoken'),
        },
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        console.log(data); // Log the data to see what is received
  
        const analysisContainer = document.getElementById("analysisResult");
        analysisContainer.innerHTML = ''; // Clear previous results
        
        // Update the webpage with the received data
        const keywordsP = document.createElement('p');
        keywordsP.textContent = "Keywords: " + data.keywords;
        analysisContainer.appendChild(keywordsP);
  
        const summaryP = document.createElement('p');
        summaryP.textContent = "Summary: " + data.summary;
        analysisContainer.appendChild(summaryP);
      })
      .catch((error) => {
        console.error('Error:', error);
      });
    });

    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
  });

</script>
{% endblock %}